---
title: "Data Wrangling"
author: "STAT 763 - Survey of Modern Statistical Software"
output: ioslides_presentation
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(out.width = '80%', collapse = TRUE, warning=FALSE, message=FALSE)
```

## Agenda

- Tibbles
- Data import
- Tidy data

- Readings: R4DS Chapters 5, 9-12
- Other sources: 
  - `vignette("tibble")
  
## Tibbles

For `tidyverse` applications, we will use a modified version of `data.frame` called a "tibble".

```{r}
library(tidyverse)
as_tibble(iris)
```

## Tibbles

```{r}
tibble(
  x = 1:5, 
  y = 1, 
  z = x ^ 2 + y
)
```

## Tibbles

Tibbles have some nice features:

- Doesn't change input types (strings to factors)
- Doesn't change variable names (use back-ticks (gravs) for non-sytactic names)
- Doesn't create row names

## Tibbles

Two main differences between tibbles and data.frames:

- Printing: tibbles by default print 10 rows and however many columns fit in the window
  - Options exist to modify this behavior (R4DS 10.3.1)
- Subsetting: selecting a variable in tibble returns a tibble (doesn't change to vector)
  - `[[ ]]` can extract by name or position; `$` only by name
  - Can pipe these as well: `df %>% .$x` (requires the `.` placeholder though, more in a minute)
  - Better options exist with the `tidyverse` though
  - Older functions (or from other packages) might expect data.frames; coerce with `as.data.frame()`

## Tidy data

_tidy_ format: each row represents one observation and columns represent the different variables available for each of these observations.

```{r, echo=FALSE}
library(dslabs)
data("gapminder")
tidy_data <- gapminder %>% 
  filter(country %in% c("South Korea", "Germany") & !is.na(fertility)) %>%
  select(country, year, fertility)
head(tidy_data, 6)
```

## Tidy data

The following represents the same data, but _untidy_:

```{r, echo=FALSE, message=FALSE}
path <- system.file("extdata", package="dslabs")
filename <- file.path(path, "fertility-two-countries-example.csv")
wide_data <- read_csv(filename)
select(wide_data, country, `1960`:`1962`) %>% as.data.frame
```

## Viewing tibbles

```{r}
glimpse(murders)
```

## Manipulating data frames

The `dplyr` package provides functions for basic data frame operations

- `mutate`: add a new column
- `filter`: filter data to a subset of rows
- `select`: subset the data by selecting columns

## Adding columns

```{r}
data("murders")
murders <- mutate(murders, rate = total/population*100000)
head(murders)
```

## Filtering rows

```{r}
filter(murders, rate <= 0.71)
```

## Filtering rows

```{r}
filter(murders, rate <= 0.71, state != "Hawaii")
```

## Filtering rows

```{r}
filter(murders, rate <= 0.71, state %in% c("Hawaii", "Iowa", "Connecticut"))
```

## Selecting columns

```{r}
new_table <- select(murders, state, region, rate)
filter(new_table, rate <= 0.71)
```

## The pipe operator

With `dplyr` (really, `magrittr`), we can send the results of one function to another directly

- End lines with the pipe operator (`%>%`, read as "and then")
- Think of each line as an intermediate object
- Allows for more abstraction/readability

## The pipe operator

```{r}
# new_table <- select(murders, state, region, rate)
# filter(new_table, rate <= 0.71)
murders %>% 
  select(state, region, rate) %>% 
  filter(rate <= 0.71)
```

## Summarizing data

We can create intuitive and readable summaries with the `summarize` function

```{r}
ss <- murders %>%
  filter(region == "South") %>%
  summarize(average = mean(rate), stdev = sd(rate))
```

## Summarizing data

Since the result of our summary is a data frame, we can use `$` for access

```{r}
ss$average
ss$stdev
```

## Summarizing data

We still need to be thoughtful when using `summarize`:

```{r}
summarize(murders, mean(rate))
us_murder_rate <- murders %>% summarize(rate = sum(total) / sum(population) * 100000)
us_murder_rate
```

## Summarizing data

```{r}
class(us_murder_rate)
us_murder_rate$rate
us_murder_rate %>% pull(rate)
```

## Group, then summarize

We can use the `group_by` function to separate the data into groups

```{r}
murders %>% group_by(region)
```

## Group, then summarize

```{r}
murders %>%
  group_by(region) %>%
  summarize(average = mean(rate), stdev = sd(rate))
```

## Sorting data frames

Instead of using base R's `order` and `sort` functions, `dplyr` provides the `arrange` function

```{r}
murders %>%
  arrange(rate) %>%
  head()
```

## Nested sorting

```{r}
murders %>%
  arrange(region, rate) %>%
  head()
```

## Top n

```{r}
#murders %>% arrange(rate) %>% head(5)
murders %>% top_n(5,rate)
```

## Dot operator

```{r}
us_murder_rate %>% pull(rate)
us_murder_rate %>% .$rate
```


## The 'do' function

The `summarize` function allows single-value returns, so the following code results in an error

```{r, eval=FALSE}
data(heights)
heights %>% 
  filter(sex == "Female") %>%
  summarize(range = quantile(height, c(0, 0.5, 1)))
```

## The 'do' function

Create a summary function.

```{r}
#Summary function
#Inputs: dat, a numeric vector
#Outputs: a tibble, with numeric min, median, and max
my_summary <- function(dat){
  x <- quantile(dat$height, c(0, 0.5, 1))
  tibble(min = x[1], median = x[2], max = x[3])
}
```

## The 'do' function

```{r}
heights %>% 
  group_by(sex) %>% 
  my_summary
```

- This isn't the same information as above, though!
- `my_summary` is not part of the tidyverse, and doesn't know how to handle grouped tibbles

## The 'do' function

This is where the `do` function comes in!

```{r}
heights %>% 
  group_by(sex) %>% 
  do(my_summary(.))
```

## The purrr package

If you use functions like `apply`, `sapply`, `mapply`, and `tapply`, check out the [purrr](https://jennybc.github.io/purrr-tutorial/)

- Great way to incorporate more functions (especially self-made)
- Integrates nicely with the rest of the tidyverse

## Tidyverse conditionals

We can extend the `ifelse` function using some `dplyr` functions. 

- Suppose we have a series/nesting of `ifelse` statements
- The code gets messy quickly
- `case_when` cleans this up a bit

```{r}
x <- c(-2, -1, 0, 1, 2)
case_when(x < 0 ~ "Negative", x > 0 ~ "Positive", TRUE ~ "Zero")
```

## case_when

- Suppose we want to compare the murder rates in four groups of states: New England, West Coast, South, and other. 
- For each state, we need to ask if it is in New England, if it is not we ask if it is in the West Coast, if not we ask if it is in the South, and if not we assign other.
- We can add this new classification to the existing dataframe

## case_when

```{r eval=FALSE}
murders %>% 
  mutate(group = case_when(
    abb %in% c("ME", "NH", "VT", "MA", "RI", "CT") ~ "New England",
    abb %in% c("WA", "OR", "CA") ~ "West Coast",
    region == "South" ~ "South",
    TRUE ~ "Other")) %>%
  group_by(group) %>%
  summarize(rate = sum(total) / sum(population) * 10^5)
```

## case_when

```{r echo=FALSE}
murders %>% 
  mutate(group = case_when(
    abb %in% c("ME", "NH", "VT", "MA", "RI", "CT") ~ "New England",
    abb %in% c("WA", "OR", "CA") ~ "West Coast",
    region == "South" ~ "South",
    TRUE ~ "Other")) %>%
  group_by(group) %>%
  summarize(rate = sum(total) / sum(population) * 10^5)
```

## between

To find if a value falls inside an interval:

```{r}
a <- -1.5; b <- 1.5
# Base R:
x >= a & x <= b
# dplyr
between(x, a, b)
```

## File paths

- Suppose we have a dataset, named `murders.csv`, stored in the `dslabs` package.
- We can find the file by defining its file path
- We can copy the file to our working directory, then import it 

```{r}
filename <- "murders.csv"
dir <- system.file("extdata", package = "dslabs") 
fullpath <- file.path(dir, filename)
file.copy(fullpath, "murders.csv")
dat <- read_csv(filename)
```

## Full path

```{r}
system.file(package = "dslabs")
getwd()

dir <- system.file(package = "dslabs")
list.files(path = dir)
```

## readr for spreadsheets

The following functions are available to read-in spreadsheets:

| Function  | Format                                           | Typical suffix |
|-----------|--------------------------------------------------|----------------| 
| read_table| white space separated values | txt |
| read_csv | comma separated values |  csv |
| read_csv2 | semicolon separated values | csv |
| read_tsv | tab delimited separated values | tsv |
| read_delim | general text file format, must define delimiter | txt |

## Double-check and read in

```{r}
read_lines("murders.csv", n_max=3)
dat <- read_csv(filename)
```

## readxl

The package provides functions to read-in Microsoft Excel formats:

| Function  | Format                                           | Typical suffix |
|-----------|--------------------------------------------------|----------------| 
| read_excel | auto detect the format | xls, xlsx|
| read_xls | original format |  xls |
| read_xlsx | new format | xlsx |

We can specify a sheet as well using these functions.

## Reshaping data

One of the most common steps after reading data is to reshape it for analyses. Let's start with some wide data.

```{r}
path <- system.file("extdata", package="dslabs")
filename <- file.path(path, "fertility-two-countries-example.csv")
wide_data <- read_csv(filename)
head(wide_data)
```

## Gather

We need three columns to represent these data in tidy format (country, year, fertility value)

```{r}
new_tidy_data <- wide_data %>% gather(year, fertility, `1960`:`2015`) 
head(new_tidy_data)
```

## Gather

```{r}
class(new_tidy_data$year) #gather() assumes column names are characters
new_tidy_data <- wide_data %>%
  gather(year, fertility, -country, convert = TRUE) #or use mutate or as.numeric
class(new_tidy_data$year)
```

## Spread

```{r}
new_wide_data <- new_tidy_data %>% spread(year, fertility)
select(new_wide_data, country, `1960`:`1967`)
```

## Separate

More commonly, we will have values for more than one variable encoded in wide format.

```{r echo=FALSE}
path <- system.file("extdata", package = "dslabs")

filename <- "life-expectancy-and-fertility-two-countries-example.csv"
filename <-  file.path(path, filename)

raw_dat <- read_csv(filename)
select(raw_dat, 1:5)
```

## Separate

```{r}
dat <- raw_dat %>% gather(key, value, -country)
head(dat)
dat %>% separate(key, c("year", "variable_name"), "_")
```

## Separate

```{r}
dat %>% separate(key, c("year", "variable_name"), extra = "merge")
```

## Separate

```{r}
dat %>% 
  separate(key, c("year", "variable_name"), extra = "merge") %>%
  spread(variable_name, value) 
```

## Unite

Does the opposite.  Check it out.

## Pivoting

You may encounter `pivot_longer()` and `pivot_wider()` 

- These are essentially the same as `gather` and `spread`

## Missing values

A missing value can manifest in two ways:

- _Explictly_: flagged with `NA`
- _Implicitly_: not present in the data

## Missing values

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

- return value for 4th quarter of 2015 is explicitly missing
- return value for 1st quarter of 2016 is implicitly missing

## Missing values

One useful tool for making missing values explicit is `complete()`

```{r}
stocks %>% 
  complete(year, qtr)
```

## Missing values

Sometimes when a data source has primarily been used for data entry, missing values indicate that the previous value should be carried forward:

```{r}
treatment <- tribble(
  ~ person,           ~ treatment, ~response,
  "Derrick Whitmore", 1,           7,
  NA,                 2,           10,
  NA,                 3,           9,
  "Katherine Burke",  1,           4
)
```

## Missing values

```{r}
treatment %>% 
  fill(person)
```

## Case study: tuberculosis

- The `tidyr::who` dataset contains tuberculosis (TB) cases broken down by year, country, age, gender, and diagnosis method. 
- The data comes from the 2014 World Health Organization Global Tuberculosis Report, available at http://www.who.int/tb/country/data/download/en/.

```{r}
who
```

## Case study: tuberculosis

- The first three letters of each column denote whether the column contains new or old cases of TB. In this dataset, each column contains new cases.
- The next two letters describe the type of TB:
  - rel stands for cases of relapse
  - ep stands for cases of extrapulmonary TB
  - sn stands for cases of pulmonary TB that could not be diagnosed by a pulmonary smear (smear negative)
  - sp stands for cases of pulmonary TB that could be diagnosed be a pulmonary smear (smear positive)
  - The sixth letter gives the sex of TB patients. The dataset groups cases by males (m) and females (f).

## Case study: tuberculosis

The remaining numbers gives the age group. The dataset groups cases into seven age groups:

- 014 = 0 – 14 years old
- 1524 = 15 – 24 years old
- 2534 = 25 – 34 years old
- 3544 = 35 – 44 years old
- 4554 = 45 – 54 years old
- 5564 = 55 – 64 years old
- 65 = 65 or older

## Case study: tuberculosis

Gather up the columns to reshape into long format

```{r}
who1 <- gather(who, key, value,'new_sp_m014':'newrel_f65')
who1
```

## Case study: tuberculosis

We need to make a minor fix to the format of the column names: unfortunately the names are slightly inconsistent because instead of `new_rel` we have `newrel` (more on `stringr` soon!)

```{r}
who2 <- who1 %>% 
  mutate(names_from = stringr::str_replace(key, "newrel", "new_rel"))
who2
```

## Case study: tuberculosis

Break apart the key

```{r}
who3 <- who2 %>% 
  separate(key, c("new", "type", "sexage"), sep = "_")
who3
```

## Case study: tuberculosis

Drop some unneeded columns

```{r}
who4 <- who3 %>% 
  select(-new, -iso2, -iso3)
```

## Case study: tuberculosis

Separate `sexage` into `sex` and `age`

```{r}
who5 <- who4 %>% 
  separate(sexage, c("sex", "age"), sep = 1)
who5
```