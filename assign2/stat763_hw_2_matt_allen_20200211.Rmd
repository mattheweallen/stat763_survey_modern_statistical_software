---
title: "Stat 763 HW 2"
author: "Matt Allen"
date: "2/15/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#built in stat 763 container
#used example here to install poppler to container OS.
#poppler is needed for pdftools
#https://github.com/aabor/rstudio/blob/master/rstudio-text/Dockerfile

library(tidyverse)
library(pdftools)
library(lubridate)
```

```{r change_file_names_here, include=FALSE}
#update the name of your file here
#heights filename
heights_file_name <- 'heights.pdf'
#ice cream filename
ice_cream_file_name <- 'ice_cream.csv'
```


```{r data_clean, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#--start create tibble for ice cream--#
ice_cream <- read.csv2(paste(getwd(),ice_cream_file_name,sep="/")
                       ,sep=",") %>%
  separate(preference, c("Preference_1","Preference_2","Preference_3"), 
           sep = ",", remove = TRUE, convert = FALSE, extra = "warn", fill = "warn") %>%
  mutate_all(str_trim)

#--start create tibble for height--#
heights <- pdf_text(paste(getwd(),heights_file_name,sep="/")) %>%
  read_lines()

#get rid of empty rows
heights <- heights[which(str_length(heights) > 0)]

#split data by Male and Female
split_on_sex <- str_split(heights[2:length(heights)],"Male|Female", simplify = TRUE)

#convert dates after split
dates <- mdy_hm(split_on_sex[1:length(heights)-1,1])

#get ids
ids <- str_extract(split_on_sex[1:length(heights)-1,2],"([a-zA-Z0-9_]+)$")

#get the heights text
#takes second column of split_on_sex
#and gets substr from beginning of string
#to (the length of the entire string - the length of the id)
heights_text <- str_sub(split_on_sex[1:length(heights)-1,2], 
                        1,
                        str_length(split_on_sex[1:length(heights)-1,2])-str_length(ids))

#pull Male and Female from data
sex <- str_extract(heights[2:length(heights)],"Male|Female")

#make tibble from vector created above
heights <- tibble(id = ids, reported_date = dates, sex = sex, height_text = str_trim(heights_text))

#attempt to convert to numeric for all data.
converted_heights <- as.numeric(heights$height_text)

#find all the heights that did not converted by getting the is.na rows
weird_heights <- heights$height_text[which(is.na(converted_heights))]

#tidy the insides of the strings
weird_heights <- str_squish(weird_heights)

#test pattern
str_view(weird_heights,pattern = "\\d'\\d+")

ft_inches <- str_which(heights$height_text,pattern = "\\d'\\d+")

pattern_to_split <- heights$height_text[ft_inches]
blarg1 <- str_split(pattern_to_split,"'", simplify = TRUE)
as.numeric(blarg1[,1])*12 + as.numeric(str_extract(blarg1[,2],"\\d+"))


#got a bunch on this, took care of 47 with 30 left to find
sum(is.na(str_extract(str_squish(weird_heights),pattern = "\\d'\\d+")))



```


## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


```{r readdata}

#filenames
heights_file_name <- '/home/rstudio/assign2/heights.pdf'
ice_cream_file_name <- '/home/rstudio/assign2/ice_cream.csv'

#temp_file <- tempfile()
#url <- paste0("http://www.pnas.org/content/suppl/2015/09/16/",
#              "1510159112.DCSupplemental/pnas.201510159SI.pdf")
#download.file(url, temp_file)
#txt <- pdf_text(temp_file)
#file.remove(temp_file)




#ice_cream_raw <- read.csv2(ice_cream_file_name,sep=",")
#str_split(ice_cream_raw$preference,",")
#https://tidyr.tidyverse.org/reference/separate.html

ice_cream <- read.csv2(ice_cream_file_name,sep=",") %>%
  separate(preference, c("Preference_1","Preference_2","Preference_3"), 
           sep = ",", remove = TRUE, convert = FALSE, extra = "warn", fill = "warn") %>%
  mutate_all(str_trim)


#heights_raw <- pdf_text(heights_file_name)




#str_split(heights[[2]],"\\s+")

# heights
# 
# 
# 
# 
# blarg <- ice_cream_raw %>%
#   separate(preference, heights_col_names, 
#            sep = "\\s+", remove = TRUE, convert = FALSE, extra = "warn", fill = "warn")
# 
# 
# #https://stackoverflow.com/questions/48833807/initialize-an-empty-tibble-with-column-names-and-0-rows
# 
# create_heights_tibble <- function(heights_pdf_text) {
#   page_num <- 1
#   row_num <- 2 # start row num at 2 because first page has columns
#   
#   
#   heights <- str_split(heights_pdf_text, "\n") 
#   heights_col_names <- str_split(heights[[page_num]][row_num],"\\s+")
#   
#   
#   
#   testy <- tibble(heights_col_names)
#   for(page in heights) {
#     #if(page_num == 1 && row_num == 1) {
#       #the first page has the row headers so need to process that one differently
#       #heights_col_names <- str_split(heights[[1]][1],"\\s+")
#       #create data table
#     #}
#     rows = str_split(page,"\\s+")
#     
#     #for(row in rows) {
#       #if(length(row) == length(heights_col_names)) {
#     bind_rows(testy,row)
#       #}
#       
#     #}
#     
#     
#     #row_num <- 1
#     #page_num = page_num + 1
#     
#   }
#   return(testy)
# }
# 
# heights <- create_heights_tibble(pdf_text(heights_file_name))
# 
# 
# ##
# for(page in heights) {
#   rows = str_split(page,"\\s+")
#   rbind()
# }
# 
# 
# which(length(heights[[2]])==3)
# heights[2]
# 
# test2 <- str_split(heights[[2]],"\\s+")
# which(length(test2) == 3)

#https://www.r-bloggers.com/extracting-pdf-text-with-r-and-creating-tidy-data/
heights <- pdf_text(heights_file_name) %>%
  read_lines()

#heights[2]
#heights_split <- str_split(heights[2:length(heights)],"\\s+")


#get rid of empty rows
#can use string split n to throw away empty rows?
#https://stringr.tidyverse.org/reference/str_split.html
heights <- heights[which(str_length(heights) > 0)]

#str_length(heights)
#length(heights)

#str_split(heights[2:length(heights)],"Male|Female", simplify = TRUE)[1:length(heights)]


split_on_sex <- str_split(heights[2:length(heights)],"Male|Female", simplify = TRUE)
split_on_sex
dates <- mdy_hm(split_on_sex[1:length(heights)-1,1])



ids <- str_extract(split_on_sex[1:length(heights)-1,2],"([a-zA-Z0-9_]*)$")
#heights_text <- str_extract(split_on_sex[1:length(heights)-1,2],"([a-zA-Z0-9_]*)$")
heights_text <- str_sub(split_on_sex[1:length(heights)-1,2],1,str_length(split_on_sex[1:length(heights)-1,2])-str_length(ids))
length(heights_text)
#length(ids)

#length(dates)
sex <- str_extract(heights[2:length(heights)],"Male|Female")
length(sex)
heights <- tibble(id = ids, reported_date = dates, sex = sex, height_text = str_trim(heights_text))


#work on recode height text

#as.numeric(heights$height_text)
#which(is.na(as.numeric(heights$height_text)))
weird_heights <- heights$height_text[which(is.na(as.numeric(heights$height_text)))]
length(weird_heights)
str_squish(weird_heights)
#str_view(c("abc", "def", "fgh"), "abc")
str_view(str_squish(weird_heights),pattern = "\\d'\\d+")

#got a bunch on this, took care of 47 with 30 left to find
sum(is.na(str_extract(str_squish(weird_heights),pattern = "\\d'\\d+")))


#str_view_all(c("abc", "def", "fgh"), "d|e")

#(fruit, "^([aeiou])")

#recode(heights$height_text, 
#                          `Antigua and Barbuda` = "Barbuda",
#                          `Dominican Republic` = "DR",
#                          `St. Vincent and the Grenadines` = "St. Vincent",
#                          `Trinidad and Tobago` = "Trinidad")

#in str_view documentation
#https://www.garrickadenbuie.com/project/regexplain/

```
